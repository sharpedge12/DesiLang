#include "../h/DesiLangProgram.h" // Header file for DesiLangProgram class
#include "../h/ErrorHandler.h"	  // Header file for error handling
#include "../h/Operator.h"		  // Header file for operator functionalities
#include "../h/AllOperators.h"	  // Header file for all operator definitions
#include "../h/CppProgram.h"	  // Header file for generating C++ code

// Function declarations
void populateDesiLangStdLib();																			   // Populate the standard library for DesiLang
void lexString(shared_ptr<SourceFile> file, vector<Token> &tokens);										   // Lexical analysis of source code into tokens
Action parseFunction(const vector<Token> &tokens, int left, int right, Type leftInType, Type rightInType); // Parse function to construct actions

// Global namespace for the program
extern Namespace globalNamespace;

// Constructor for DesiLangProgram
DesiLangProgram::DesiLangProgram()
{
	// Initializes the program
}

// Cleans up resources used by the program
void DesiLangProgram::cleanUp()
{
	// Placeholder for cleanup logic
}

// Resolves the program from a given filename and optionally prints the output
void DesiLangProgram::resolveProgram(string inFilename, bool printOutput)
{
	// Initialize all operators
	AllOperators::init();
	// Populate the standard library
	populateDesiLangStdLib();

	// Placeholder for potential initial population of the program
	// initialProgramPopulation();

	// Placeholder for resolving the global frame
	// globalFrame.resolve(printOutput);

	// Check if any error is logged
	if (!error.getIfErrorLogged())
	{
		try
		{
			// Load the source file
			file = shared_ptr<SourceFile>(new SourceFile(inFilename, printOutput));

			if (printOutput)
			{
				// Print the source file content in a boxed format
				cout << endl
					 << endl
					 << file->getBoxedString() << endl;
			}
		}
		catch (DesiLangError err)
		{
			// Log errors related to loading the source file
			err.log();
		}
	}

	if (!error.getIfErrorLogged())
	{
		try
		{
			// Perform lexical analysis to generate tokens from the source file
			lexString(file, tokens);
		}
		catch (DesiLangError err)
		{
			// Log errors during lexical analysis
			err.log();
			astRoot = AstVoid::make(); // Assign an empty AST root
		}

		/*
		if (printOutput)
		{
			// Print the tokens generated by the lexer
			cout << endl << tableStringFromTokens(tokens, "lexer output") << endl;
		}
		*/
	}

	// Placeholder for parsing tokens into an AST (abstract syntax tree)
	// astRoot = parseFunction(tokens, 0, tokens.size() - 1, Void, Void);

	if (!error.getIfErrorLogged())
	{
		try
		{
			// Generate the abstract syntax tree (AST) from tokens
			astRoot = astNodeFromTokens(tokens, 0, tokens.size() - 1);
		}
		catch (DesiLangError err)
		{
			// Log errors during AST generation
			err.log();
			astRoot = AstVoid::make(); // Assign an empty AST root
		}

		if (printOutput)
		{
			// Print the abstract syntax tree (AST)
			cout << " ╭──────────────────────╮" << endl;
			cout << " │ abstract syntax tree │" << endl;
			cout << " ╰──────────────────────╯" << endl;
			cout << astRoot->getString() << endl;
		}
	}

	if (!error.getIfErrorLogged())
	{
		try
		{
			// Resolve the AST in the context of the global namespace
			astRoot->setInput(globalNamespace, true, Void, Void);
		}
		catch (DesiLangError err)
		{
			// Log errors during AST resolution
			err.log();
			astRoot = AstVoid::make(); // Assign an empty AST root
		}

		try
		{
			// Generate the action tree from the AST
			actionRoot = astRoot->getAction();

			if (printOutput)
			{
				// Print the action tree
				cout << " ╭─────────────╮" << endl;
				cout << " │ action tree │" << endl;
				cout << " ╰─────────────╯" << endl;
				cout << actionRoot->getDescription() << endl;
			}
		}
		catch (DesiLangError err)
		{
			// Log errors during action tree generation
			err.log();
		}
	}

	/*
	if (printOutput)
	{
		// Print the generated C source code (commented out)
		cout << endl << "C source code:\n" << astRoot->getCSource() << endl;
	}
	*/
}

// Generates C++ code from the program
string DesiLangProgram::getCpp()
{
	try
	{
		CppProgram outProg;										 // Create a new C++ program object
		actionRoot->addToProg(voidAction, voidAction, &outProg); // Add actions to the program
		return outProg.getCppCode();							 // Return the generated C++ code
	}
	catch (DesiLangError err)
	{
		// Log errors during C++ code generation
		err.log();
		return "/* transpiling error ke karan koi program nhi hai */";
	}
}

// Executes the program
void DesiLangProgram::execute()
{
	try
	{
		// Allocate memory for the global frame and stack
		stackPtr = globalFramePtr = malloc(globalNamespace->getStackFrame()->getSize());
		// Execute the action tree and free memory
		free(actionRoot->execute(nullptr, nullptr));
		free(globalFramePtr);
		stackPtr = globalFramePtr = nullptr; // Reset pointers
	}
	catch (DesiLangError err)
	{
		// Log errors during execution
		err.log();
		cout << endl
			 << ">>>>>>    error ke karan program abort ho gya     <<<<<<" << endl;
	}
}
